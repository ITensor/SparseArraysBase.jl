var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#SparseArraysBase.SparseArrayDOK","page":"Reference","title":"SparseArraysBase.SparseArrayDOK","text":"SparseArrayDOK{T,N,F} <: AbstractSparseArray{T,N}\n\nN-dimensional sparse Dictionary-of-keys (DOK) array with elements of type T, optionally with a function of type F to instantiate non-stored elements.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SparseArraysBase.SparseArrayDOK-Union{Tuple{N}, Tuple{T}, Tuple{UndefInitializer, Any}} where {T, N}","page":"Reference","title":"SparseArraysBase.SparseArrayDOK","text":"SparseArrayDOK{T}(undef, dims...[; getunstored])\nSparseArrayDOK{T,N}(undef, dims...[; getunstored])\n\nConstruct an uninitialized N-dimensional SparseArrayDOK containing elements of type T. N can either be supplied explicitly, or be determined by the length or number of dims.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SparseArraysBase.ZeroPreserving","page":"Reference","title":"SparseArraysBase.ZeroPreserving","text":"abstract type ZeroPreserving <: Function end\n\nHoly Trait to indicate how a function interacts with abstract zero values:\n\nStrongPreserving : output is guaranteed to be zero if any input is.\nWeakPreserving : output is guaranteed to be zero if all inputs are.\nNonPreserving : no guarantees on output.\n\nTo attempt to automatically determine this, either ZeroPreserving(f, A::AbstractArray...) or ZeroPreserving(f, T::Type...) can be used/overloaded.\n\nwarning: Warning\nincorrectly registering a function to be zero-preserving will lead to silently wrong results.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SparseArraysBase.eachstoredindex","page":"Reference","title":"SparseArraysBase.eachstoredindex","text":"eachstoredindex(A::AbstractArray...)\neachstoredindex(style::IndexStyle, A::AbstractArray...)\n\nAn iterable over all indices of the stored values. For multiple arrays, the iterable contains all indices where at least one input has a stored value. The type of indices can be controlled through style, which will default to a compatible style for all inputs.\n\nThe order of the iterable is not guaranteed to be fixed or sorted, and should not be assumed to be the same as storedvalues.\n\nSee also storedvalues, storedpairs and storedlength.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SparseArraysBase.getstoredindex-Tuple{AbstractArray, Vararg{Any}}","page":"Reference","title":"SparseArraysBase.getstoredindex","text":"getstoredindex(A::AbstractArray, I...) -> eltype(A)\n\nObtain getindex(A, I...) with the guarantee that there is a stored entry at that location.\n\nSimilar to Base.getindex, new definitions should be in line with IndexStyle(A).\n\n\n\n\n\n","category":"method"},{"location":"reference/#SparseArraysBase.getunstoredindex-Tuple{AbstractArray, Vararg{Any}}","page":"Reference","title":"SparseArraysBase.getunstoredindex","text":"getunstoredindex(A::AbstractArray, I...) -> eltype(A)\n\nObtain the value that would be returned by getindex(A, I...) when there is no stored entry at that location. By default, this takes an explicit copy of the getindex implementation to mimick a newly instantiated object.\n\nSimilar to Base.getindex, new definitions should be in line with IndexStyle(A).\n\n\n\n\n\n","category":"method"},{"location":"reference/#SparseArraysBase.isstored-Tuple{AbstractArray, Vararg{Any}}","page":"Reference","title":"SparseArraysBase.isstored","text":"isstored(A::AbstractArray, I...) -> Bool\n\nCheck if the array A has a stored entry at the location specified by indices I.... For generic array types this defaults to true whenever the indices are inbounds, but sparse array types might overload this function when appropriate.\n\nSimilar to Base.getindex, new definitions should be in line with IndexStyle(A).\n\n\n\n\n\n","category":"method"},{"location":"reference/#SparseArraysBase.setstoredindex!-Tuple{AbstractArray, Any, Vararg{Any}}","page":"Reference","title":"SparseArraysBase.setstoredindex!","text":"setstoredindex!(A::AbstractArray, v, I...) -> A\n\nsetindex!(A, v, I...) with the guarantee that there is a stored entry at the given location.\n\nSimilar to Base.setindex!, new definitions should be in line with IndexStyle(A).\n\n\n\n\n\n","category":"method"},{"location":"reference/#SparseArraysBase.setunstoredindex!-Tuple{AbstractArray, Any, Vararg{Any}}","page":"Reference","title":"SparseArraysBase.setunstoredindex!","text":"setunstoredindex!(A::AbstractArray, v, I...) -> A\n\nsetindex!(A, v, I...) with the guarantee that there is no stored entry at the given location.\n\nSimilar to Base.setindex!, new definitions should be in line with IndexStyle(A).\n\n\n\n\n\n","category":"method"},{"location":"reference/#SparseArraysBase.sparse-Tuple{Union{AbstractDict, Dictionaries.AbstractDictionary}, Vararg{Any}}","page":"Reference","title":"SparseArraysBase.sparse","text":"sparse(storage::Union{AbstractDict,AbstractDictionary}, dims...[; getunstored])\n\nConstruct an N-dimensional SparseArrayDOK containing elements of type T. Both T and N can either be supplied explicitly or be determined by the storage and the length or number of dims. If dims aren't specified, the size will be determined automatically from the input indices.\n\nThis constructor does not take ownership of the supplied storage, and will result in an independent container.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SparseArraysBase.sparserand","page":"Reference","title":"SparseArraysBase.sparserand","text":"sparserand([rng], [T::Type], dims; density::Real=0.5, randfun::Function=rand) -> A::SparseArrayDOK{T}\n\nCreate a random size dims sparse array in which the probability of any element being stored is independently given by density. The optional rng argument specifies a random number generator, see also Random. The optional T argument specifies the element type, which defaults to Float64. The optional randfun argument can be used to control the type of random elements, and should support the signature randfun(rng, T, N) to generate N entries of type T.\n\nSee also sparserand!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SparseArraysBase.sparserand!","page":"Reference","title":"SparseArraysBase.sparserand!","text":"sparserand!([rng], A::AbstractArray; density::Real=0.5, randfun::Function=rand) -> A\n\nOverwrite part of an array with random entries, where the probability of overwriting is independently given by density. The optional rng argument specifies a random number generator, see also Random. The optional randfun argument can be used to control the type of random elements, and should support the signature randfun(rng, T, N) to generate N entries of type T.\n\nSee also sparserand.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SparseArraysBase.sparsezeros","page":"Reference","title":"SparseArraysBase.sparsezeros","text":"sparsezeros([T::Type], dims[; getunstored]) -> A::SparseArrayDOK{T}\n\nCreate an empty size dims sparse array. The optional T argument specifies the element type, which defaults to Float64.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SparseArraysBase.storedlength","page":"Reference","title":"SparseArraysBase.storedlength","text":"storedlength(A::AbstractArray) -> Int\n\nThe number of values that are currently being stored.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SparseArraysBase.storedpairs","page":"Reference","title":"SparseArraysBase.storedpairs","text":"storedpairs(A::AbstractArray) -> (k, v)...\n\nAn iterable over all stored indices and their corresponding stored values. The indices are compatible with IndexStyle(A).\n\nThe order of the iterable is not guaranteed to be fixed or sorted. See also eachstoredindex and storedvalues.\n\n\n\n\n\n","category":"function"},{"location":"reference/#SparseArraysBase.storedvalues","page":"Reference","title":"SparseArraysBase.storedvalues","text":"storedvalues(A::AbstractArray) -> v...\n\nAn iterable over all stored values.\n\nThe order of the iterable is not guaranteed to be fixed or sorted, and should not be assumed to be the same as eachstoredindex.\n\n\n\n\n\n","category":"function"},{"location":"#SparseArraysBase.jl","page":"Home","title":"SparseArraysBase.jl","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue) (Image: Aqua)","category":"section"},{"location":"#Support","page":"Home","title":"Support","text":"<img class=\"display-light-only\" src=\"assets/CCQ.png\" width=\"20%\" alt=\"Flatiron Center for Computational Quantum Physics logo.\"/>\n<img class=\"display-dark-only\" src=\"assets/CCQ-dark.png\" width=\"20%\" alt=\"Flatiron Center for Computational Quantum Physics logo.\"/>\n\nSparseArraysBase.jl is supported by the Flatiron Institute, a division of the Simons Foundation.","category":"section"},{"location":"#Installation-instructions","page":"Home","title":"Installation instructions","text":"This package resides in the ITensor/ITensorRegistry local registry. In order to install, simply add that registry through your package manager. This step is only required once.\n\njulia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\")\n\nor:\n\njulia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\")\n\nif you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages.\n\nThen, the package can be added as usual through the package manager:\n\njulia> Pkg.add(\"SparseArraysBase\")","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"using SparseArraysBase:\n  SparseArrayDOK,\n  SparseMatrixDOK,\n  SparseVectorDOK,\n  eachstoredindex,\n  getstoredindex,\n  getunstoredindex,\n  isstored,\n  setstoredindex!,\n  setunstoredindex!,\n  storedlength,\n  storedpairs,\n  storedvalues,\n  zero!\nusing Test: @test, @test_throws\n\na = SparseArrayDOK{Float64}(undef, 2, 2)\n\nAbstractArray interface:\n\n@test iszero(a)\n@test iszero(sum(a))\n@test iszero(storedlength(a))\n\na[1, 2] = 12\n@test a == [0 12; 0 0]\n@test a[1, 1] == 0\n@test a[2, 1] == 0\n@test a[1, 2] == 12\n@test a[2, 2] == 0\n\nSparseArraysBase interface:\n\nusing Dictionaries: IndexError\n@test issetequal(eachstoredindex(a), [CartesianIndex(1, 2)])\n@test getstoredindex(a, 1, 2) == 12\n@test_throws IndexError getstoredindex(a, 1, 1)\n@test getunstoredindex(a, 1, 1) == 0\n@test getunstoredindex(a, 1, 2) == 0\n@test !isstored(a, 1, 1)\n@test isstored(a, 1, 2)\n@test setstoredindex!(copy(a), 21, 1, 2) == [0 21; 0 0]\n@test_throws IndexError setstoredindex!(copy(a), 21, 2, 1)\n@test_throws IndexError setunstoredindex!(copy(a), 21, 1, 2) == [0 21; 0 0]\n@test storedlength(a) == 1\n@test issetequal(storedpairs(a), [CartesianIndex(1, 2) => 12])\n@test issetequal(storedvalues(a), [12])\n@test sum(a) == 12\n@test isreal(a)\n@test !iszero(a)\n@test mapreduce(x -> 2x, +, a) == 24\n\nAbstractArray functionality:\n\nb = a .+ 2 .* a'\n@test b isa SparseMatrixDOK{Float64}\n@test b == [0 12; 24 0]\n@test storedlength(b) == 2\n@test sum(b) == 36\n@test isreal(b)\n@test !iszero(b)\n@test mapreduce(x -> 2x, +, b) == 72\n\nb = permutedims(a, (2, 1))\n@test b isa SparseMatrixDOK{Float64}\n@test b[1, 1] == a[1, 1]\n@test b[2, 1] == a[1, 2]\n@test b[1, 2] == a[2, 1]\n@test b[2, 2] == a[2, 2]\n\nb = a * a'\n@test b isa SparseMatrixDOK{Float64}\n@test b == [144 0; 0 0]\n@test storedlength(b) == 1\n\nSecond column.\n\nb = a[1:2, 2]\n@test b isa SparseVectorDOK{Float64}\n@test b == [12, 0]\n@test storedlength(b) == 1\n\na = SparseArrayDOK{Float64}(undef, 2, 2)\na .= 2\nfor I in eachindex(a)\n  @test a[I] == 2\nend\n@test storedlength(a) == length(a)\n\na = SparseArrayDOK{Float64}(undef, 2, 2)\nfill!(a, 2)\nfor I in eachindex(a)\n  @test a[I] == 2\nend\n@test storedlength(a) == length(a)\n\na = SparseArrayDOK{Float64}(undef, 2, 2)\nfill!(a, 0)\n@test iszero(a)\n@test iszero(storedlength(a))\n\na = SparseArrayDOK{Float64}(undef, 2, 2)\na[1, 2] = 12\nzero!(a)\n@test iszero(a)\n@test iszero(storedlength(a))\n\na = SparseArrayDOK{Float64}(undef, 2, 2)\na[1, 2] = 12\nb = zero(a)\n@test iszero(b)\n@test iszero(storedlength(b))\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
